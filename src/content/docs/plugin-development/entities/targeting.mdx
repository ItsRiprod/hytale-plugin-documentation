---
title: "Player Targeting"
---

import { Aside, Tabs, TabItem, Steps } from '@astrojs/starlight/components';

{/* [VERIFIED: 2026-01-25] */}

# Player Targeting

Getting what a player is looking at, handling mouse input, and implementing targeting mechanics like click-and-drag interactions.

## Package Locations

- **TargetUtil**: `com.hypixel.hytale.server.core.util.TargetUtil`
- **Mouse Events**: `com.hypixel.hytale.server.core.event.events.player`
- **Sync Data**: `com.hypixel.hytale.protocol.InteractionSyncData`
- **Raycast**: `com.hypixel.hytale.server.core.modules.interaction.interaction.config.selector.RaycastSelector`

## TargetUtil

The primary utility class for raycast-based targeting. Use this to determine what entity or block a player is looking at.

### Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `getTargetEntity(playerRef, accessor)` | `Ref<EntityStore>` | Entity player is looking at (8-block range) |
| `getTargetBlock(playerRef, distance, accessor)` | `Vector3i` | Block player is looking at |
| `getTargetLocation(playerRef, accessor)` | `Vector3d` | Precise hit location with decimals |
| `getLook(playerRef, accessor)` | `Transform` | Player's eye position and look direction |

### Basic Usage

```java title="Getting target entity and block"
// Get the entity a player is looking at (within 8 blocks)
Ref<EntityStore> targetEntity = TargetUtil.getTargetEntity(playerRef, componentAccessor);
if (targetEntity != null) {
    // Player is looking at an entity
    processTarget(targetEntity);
}

// Get target block within 30 blocks
Vector3i targetBlock = TargetUtil.getTargetBlock(playerRef, 30.0, componentAccessor);

// Get precise hit location (with decimal coordinates)
Vector3d targetLocation = TargetUtil.getTargetLocation(playerRef, componentAccessor);
```

### Custom Raycasting

```java title="Using look direction for custom raycast"
Transform look = TargetUtil.getLook(playerRef, componentAccessor);
Vector3d eyePosition = look.getPosition();
Vector3d direction = look.getDirection();

// Use for custom raycast calculations
Vector3d endPoint = eyePosition.add(direction.mul(50.0));
```

## Mouse Events

Mouse events provide real-time information about player clicks and cursor movement, including what entity or block is under the cursor.

### PlayerMouseButtonEvent

Fired when a player clicks a mouse button.

```java title="PlayerMouseButtonEvent fields"
public class PlayerMouseButtonEvent extends PlayerEvent<Void> implements ICancellable {
    public PlayerRef getPlayerRef();
    public float getClientUseTime();
    public ItemStack getItemInHand();
    public TargetBlock getTargetBlock();      // Block being clicked
    public TargetEntity getTargetEntity();    // Entity being clicked
    public Vector2f getScreenPoint();         // Screen coordinates (x, y)
    public MouseButton getMouseButton();      // PRIMARY, SECONDARY, etc.
}
```

### PlayerMouseMotionEvent

Fired when a player moves their mouse.

```java title="PlayerMouseMotionEvent fields"
public class PlayerMouseMotionEvent extends PlayerEvent<Void> implements ICancellable {
    public PlayerRef getPlayerRef();
    public TargetBlock getTargetBlock();      // Block under cursor
    public TargetEntity getTargetEntity();    // Entity under cursor
    public Vector2f getScreenPoint();         // Screen coordinates
    public MouseMotionEvent getMouseMotion(); // Motion delta info
}
```

### Mouse Button Types

| Value | Description |
|-------|-------------|
| `PRIMARY` | Left click |
| `SECONDARY` | Right click |
| `ABILITY1` | Ability slot 1 |
| `ABILITY2` | Ability slot 2 |
| `ABILITY3` | Ability slot 3 |

## Click-and-Drag Implementation

<Aside type="tip">
For implementing mechanics where players click on entities and drag them to new positions, use a combination of `PlayerMouseButtonEvent` to detect the initial click and `PlayerMouseMotionEvent` to track movement.
</Aside>

### Example: Entity Dragging System

```java title="EntityDragHandler.java"
public class EntityDragHandler {
    private Map<UUID, Ref<EntityStore>> draggingEntities = new HashMap<>();

    public void setup(EventRegistry eventRegistry) {
        // Detect right-click on entity to start drag
        eventRegistry.register(PlayerMouseButtonEvent.class, event -> {
            if (event.getMouseButton() != MouseButton.SECONDARY) {
                return;
            }

            TargetEntity target = event.getTargetEntity();
            if (target == null) {
                return;
            }

            Ref<EntityStore> entityRef = target.getEntityRef();
            if (isDraggable(entityRef)) {
                UUID playerUuid = event.getPlayerRef().getUuid();
                draggingEntities.put(playerUuid, entityRef);
                event.setCancelled(true);
            }
        });

        // Track mouse movement during drag
        eventRegistry.register(PlayerMouseMotionEvent.class, event -> {
            UUID playerUuid = event.getPlayerRef().getUuid();
            Ref<EntityStore> draggedEntity = draggingEntities.get(playerUuid);

            if (draggedEntity == null) {
                return;
            }

            // Get current target position from mouse
            TargetBlock targetBlock = event.getTargetBlock();
            if (targetBlock != null) {
                Vector3i blockPos = targetBlock.getPosition();
                // Move entity to target position (offset up by 1 block)
                Vector3d newPos = blockPos.toVector3d().add(0.5, 1.0, 0.5);
                moveEntityTo(draggedEntity, newPos);
            }
        });
    }

    public void stopDragging(UUID playerUuid) {
        draggingEntities.remove(playerUuid);
    }

    private boolean isDraggable(Ref<EntityStore> entity) {
        // Check if entity has draggable tag/component
        return true;
    }

    private void moveEntityTo(Ref<EntityStore> entity, Vector3d position) {
        // Set entity position using ECS
    }
}
```

### Detecting Button Release

<Aside type="caution">
Mouse button release events may need to be detected via the interaction system or by tracking button state changes between `PlayerMouseButtonEvent` calls.
</Aside>

## InteractionSyncData

When working within the interaction system, `InteractionSyncData` provides client-sent raycast information:

```java title="InteractionSyncData fields"
public class InteractionSyncData {
    public int entityId;           // ID of targeted entity
    public float[] raycastHit;     // Hit position (x, y, z)
    public float raycastDistance;  // Distance to hit point
    public float[] raycastNormal;  // Surface normal at hit (x, y, z)
    public float[] attackerPos;    // Attacker position
    public float[] attackerRot;    // Attacker rotation (yaw, pitch)
    public int[] blockPosition;    // Block being targeted
    public HitEntityData[] hitEntities; // Array of hit entities with details
}
```

## Interaction Context Metadata

Within interaction handlers, access targets via the context metadata store:

```java title="Accessing targets in interactions"
public void handleInteraction(InteractionContext context) {
    DynamicMetaStore<InteractionContext> meta = context.getMetaStore();

    // Get target entity
    Ref<EntityStore> targetEntity = meta.get(Interaction.TARGET_ENTITY);

    // Get target block
    BlockPosition targetBlock = meta.get(Interaction.TARGET_BLOCK);

    // Get precise hit location (Vector4d)
    Vector4d hitLocation = meta.get(Interaction.HIT_LOCATION);

    // Get additional hit detail info
    String hitDetail = meta.get(Interaction.HIT_DETAIL);
}
```

### Metadata Keys

| Key | Type | Description |
|-----|------|-------------|
| `Interaction.TARGET_ENTITY` | `Ref<EntityStore>` | Targeted entity reference |
| `Interaction.TARGET_BLOCK` | `BlockPosition` | Targeted block position |
| `Interaction.HIT_LOCATION` | `Vector4d` | Precise hit point |
| `Interaction.HIT_DETAIL` | `String` | Additional hit information |

## RaycastSelector

For advanced targeting configuration within the interaction system:

```java title="RaycastSelector configuration"
public class RaycastSelector implements Selector {
    public float Distance = 30f;        // Max raycast distance
    public float[] Offset;              // Offset from origin
    public String BlockTag;             // Filter blocks by tag
    public boolean IgnoreFluids = true; // Skip fluid blocks

    // Select target position
    public Vector3d selectTargetPosition(InteractionContext context);

    // Get entities hit by raycast
    public List<Ref<EntityStore>> selectTargetEntities(InteractionContext context);

    // Get blocks hit by raycast
    public List<BlockPosition> selectTargetBlocks(InteractionContext context);
}
```

## Quick Reference

| Need | Solution |
|------|----------|
| Get targeted entity | `TargetUtil.getTargetEntity()` |
| Get targeted block | `TargetUtil.getTargetBlock()` |
| Get precise hit location | `TargetUtil.getTargetLocation()` |
| Get look direction | `TargetUtil.getLook()` |
| Detect click on entity | `PlayerMouseButtonEvent.getTargetEntity()` |
| Track cursor movement | `PlayerMouseMotionEvent` |
| Client raycast data | `InteractionSyncData` |
| Targets in interactions | `InteractionContext.getMetaStore()` |

## Best Practices

<Steps>
1. **Always null-check targets** - Both `getTargetEntity()` and `getTargetBlock()` can return null if player isn't looking at anything valid

2. **Validate distance** - Verify the target is within an acceptable range for your mechanic

3. **Cancel events when handling** - Call `event.setCancelled(true)` when consuming mouse events to prevent default behavior

4. **Clean up on disconnect** - Remove any drag state or tracking data when players disconnect

5. **Use TargetUtil for simplicity** - Prefer `TargetUtil` methods over manual raycast calculations
</Steps>

## Related

- [Event Catalog](/plugin-development/events/event-catalog/) - Complete event reference including mouse events
- [Interaction System](/plugin-development/interactions/overview/) - Interaction chain system
- [ECS Overview](/plugin-development/ecs/overview/) - Entity component system for manipulating entities
